{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallbackWorkflow = void 0;\nconst bson_1 = require(\"bson\");\nconst error_1 = require(\"../../../error\");\nconst utils_1 = require(\"../../../utils\");\nconst providers_1 = require(\"../providers\");\nconst callback_lock_cache_1 = require(\"./callback_lock_cache\");\nconst token_entry_cache_1 = require(\"./token_entry_cache\");\n/** The current version of OIDC implementation. */\nconst OIDC_VERSION = 0;\n/** 5 minutes in seconds */\nconst TIMEOUT_S = 300;\n/** Properties allowed on results of callbacks. */\nconst RESULT_PROPERTIES = ['accessToken', 'expiresInSeconds', 'refreshToken'];\n/** Error message when the callback result is invalid. */\nconst CALLBACK_RESULT_ERROR = 'User provided OIDC callbacks must return a valid object with an accessToken.';\n/**\n * OIDC implementation of a callback based workflow.\n * @internal\n */\nclass CallbackWorkflow {\n  /**\n   * Instantiate the workflow\n   */\n  constructor() {\n    this.cache = new token_entry_cache_1.TokenEntryCache();\n    this.callbackCache = new callback_lock_cache_1.CallbackLockCache();\n  }\n  /**\n   * Get the document to add for speculative authentication. This also needs\n   * to add a db field from the credentials source.\n   */\n  async speculativeAuth(credentials) {\n    const document = startCommandDocument(credentials);\n    document.db = credentials.source;\n    return {\n      speculativeAuthenticate: document\n    };\n  }\n  /**\n   * Execute the OIDC callback workflow.\n   */\n  async execute(connection, credentials, reauthenticating, response) {\n    // Get the callbacks with locks from the callback lock cache.\n    const {\n      requestCallback,\n      refreshCallback,\n      callbackHash\n    } = this.callbackCache.getCallbacks(connection, credentials);\n    // Look for an existing entry in the cache.\n    const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);\n    let result;\n    if (entry) {\n      // Reauthentication cannot use a token from the cache since the server has\n      // stated it is invalid by the request for reauthentication.\n      if (entry.isValid() && !reauthenticating) {\n        // Presence of a valid cache entry means we can skip to the finishing step.\n        result = await this.finishAuthentication(connection, credentials, entry.tokenResult, response?.speculativeAuthenticate?.conversationId);\n      } else {\n        // Presence of an expired cache entry means we must fetch a new one and\n        // then execute the final step.\n        const tokenResult = await this.fetchAccessToken(connection, credentials, entry.serverInfo, reauthenticating, callbackHash, requestCallback, refreshCallback);\n        try {\n          result = await this.finishAuthentication(connection, credentials, tokenResult, reauthenticating ? undefined : response?.speculativeAuthenticate?.conversationId);\n        } catch (error) {\n          // If we are reauthenticating and this errors with reauthentication\n          // required, we need to do the entire process over again and clear\n          // the cache entry.\n          if (reauthenticating && error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.Reauthenticate) {\n            this.cache.deleteEntry(connection.address, credentials.username, callbackHash);\n            result = await this.execute(connection, credentials, reauthenticating);\n          } else {\n            throw error;\n          }\n        }\n      }\n    } else {\n      // No entry in the cache requires us to do all authentication steps\n      // from start to finish, including getting a fresh token for the cache.\n      const startDocument = await this.startAuthentication(connection, credentials, reauthenticating, response);\n      const conversationId = startDocument.conversationId;\n      const serverResult = bson_1.BSON.deserialize(startDocument.payload.buffer);\n      const tokenResult = await this.fetchAccessToken(connection, credentials, serverResult, reauthenticating, callbackHash, requestCallback, refreshCallback);\n      result = await this.finishAuthentication(connection, credentials, tokenResult, conversationId);\n    }\n    return result;\n  }\n  /**\n   * Starts the callback authentication process. If there is a speculative\n   * authentication document from the initial handshake, then we will use that\n   * value to get the issuer, otherwise we will send the saslStart command.\n   */\n  async startAuthentication(connection, credentials, reauthenticating, response) {\n    let result;\n    if (!reauthenticating && response?.speculativeAuthenticate) {\n      result = response.speculativeAuthenticate;\n    } else {\n      result = await connection.commandAsync((0, utils_1.ns)(credentials.source), startCommandDocument(credentials), undefined);\n    }\n    return result;\n  }\n  /**\n   * Finishes the callback authentication process.\n   */\n  async finishAuthentication(connection, credentials, tokenResult, conversationId) {\n    const result = await connection.commandAsync((0, utils_1.ns)(credentials.source), finishCommandDocument(tokenResult.accessToken, conversationId), undefined);\n    return result;\n  }\n  /**\n   * Fetches an access token using either the request or refresh callbacks and\n   * puts it in the cache.\n   */\n  async fetchAccessToken(connection, credentials, serverInfo, reauthenticating, callbackHash, requestCallback, refreshCallback) {\n    // Get the token from the cache.\n    const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);\n    let result;\n    const context = {\n      timeoutSeconds: TIMEOUT_S,\n      version: OIDC_VERSION\n    };\n    // Check if there's a token in the cache.\n    if (entry) {\n      // If the cache entry is valid, return the token result.\n      if (entry.isValid() && !reauthenticating) {\n        return entry.tokenResult;\n      }\n      // If the cache entry is not valid, remove it from the cache and first attempt\n      // to use the refresh callback to get a new token. If no refresh callback\n      // exists, then fallback to the request callback.\n      if (refreshCallback) {\n        context.refreshToken = entry.tokenResult.refreshToken;\n        result = await refreshCallback(serverInfo, context);\n      } else {\n        result = await requestCallback(serverInfo, context);\n      }\n    } else {\n      // With no token in the cache we use the request callback.\n      result = await requestCallback(serverInfo, context);\n    }\n    // Validate that the result returned by the callback is acceptable. If it is not\n    // we must clear the token result from the cache.\n    if (isCallbackResultInvalid(result)) {\n      this.cache.deleteEntry(connection.address, credentials.username, callbackHash);\n      throw new error_1.MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);\n    }\n    // Cleanup the cache.\n    this.cache.deleteExpiredEntries();\n    // Put the new entry into the cache.\n    this.cache.addEntry(connection.address, credentials.username || '', callbackHash, result, serverInfo);\n    return result;\n  }\n}\nexports.CallbackWorkflow = CallbackWorkflow;\n/**\n * Generate the finishing command document for authentication. Will be a\n * saslStart or saslContinue depending on the presence of a conversation id.\n */\nfunction finishCommandDocument(token, conversationId) {\n  if (conversationId != null && typeof conversationId === 'number') {\n    return {\n      saslContinue: 1,\n      conversationId: conversationId,\n      payload: new bson_1.Binary(bson_1.BSON.serialize({\n        jwt: token\n      }))\n    };\n  }\n  // saslContinue requires a conversationId in the command to be valid so in this\n  // case the server allows \"step two\" to actually be a saslStart with the token\n  // as the jwt since the use of the cached value has no correlating conversating\n  // on the particular connection.\n  return {\n    saslStart: 1,\n    mechanism: providers_1.AuthMechanism.MONGODB_OIDC,\n    payload: new bson_1.Binary(bson_1.BSON.serialize({\n      jwt: token\n    }))\n  };\n}\n/**\n * Determines if a result returned from a request or refresh callback\n * function is invalid. This means the result is nullish, doesn't contain\n * the accessToken required field, and does not contain extra fields.\n */\nfunction isCallbackResultInvalid(tokenResult) {\n  if (tokenResult == null || typeof tokenResult !== 'object') return true;\n  if (!('accessToken' in tokenResult)) return true;\n  return !Object.getOwnPropertyNames(tokenResult).every(prop => RESULT_PROPERTIES.includes(prop));\n}\n/**\n * Generate the saslStart command document.\n */\nfunction startCommandDocument(credentials) {\n  const payload = {};\n  if (credentials.username) {\n    payload.n = credentials.username;\n  }\n  return {\n    saslStart: 1,\n    autoAuthorize: 1,\n    mechanism: providers_1.AuthMechanism.MONGODB_OIDC,\n    payload: new bson_1.Binary(bson_1.BSON.serialize(payload))\n  };\n}","map":{"version":3,"names":["bson_1","require","error_1","utils_1","providers_1","callback_lock_cache_1","token_entry_cache_1","OIDC_VERSION","TIMEOUT_S","RESULT_PROPERTIES","CALLBACK_RESULT_ERROR","CallbackWorkflow","constructor","cache","TokenEntryCache","callbackCache","CallbackLockCache","speculativeAuth","credentials","document","startCommandDocument","db","source","speculativeAuthenticate","execute","connection","reauthenticating","response","requestCallback","refreshCallback","callbackHash","getCallbacks","entry","getEntry","address","username","result","isValid","finishAuthentication","tokenResult","conversationId","fetchAccessToken","serverInfo","undefined","error","MongoError","code","MONGODB_ERROR_CODES","Reauthenticate","deleteEntry","startDocument","startAuthentication","serverResult","BSON","deserialize","payload","buffer","commandAsync","ns","finishCommandDocument","accessToken","context","timeoutSeconds","version","refreshToken","isCallbackResultInvalid","MongoMissingCredentialsError","deleteExpiredEntries","addEntry","exports","token","saslContinue","Binary","serialize","jwt","saslStart","mechanism","AuthMechanism","MONGODB_OIDC","Object","getOwnPropertyNames","every","prop","includes","n","autoAuthorize"],"sources":["C:\\Users\\kin_v\\OneDrive\\Documents\\Orbital\\orbital-code\\node_modules\\mongodb\\src\\cmap\\auth\\mongodb_oidc\\callback_workflow.ts"],"sourcesContent":["import { Binary, BSON, type Document } from 'bson';\n\nimport { MONGODB_ERROR_CODES, MongoError, MongoMissingCredentialsError } from '../../../error';\nimport { ns } from '../../../utils';\nimport type { Connection } from '../../connection';\nimport type { MongoCredentials } from '../mongo_credentials';\nimport type {\n  IdPServerInfo,\n  IdPServerResponse,\n  OIDCCallbackContext,\n  OIDCRefreshFunction,\n  OIDCRequestFunction,\n  Workflow\n} from '../mongodb_oidc';\nimport { AuthMechanism } from '../providers';\nimport { CallbackLockCache } from './callback_lock_cache';\nimport { TokenEntryCache } from './token_entry_cache';\n\n/** The current version of OIDC implementation. */\nconst OIDC_VERSION = 0;\n\n/** 5 minutes in seconds */\nconst TIMEOUT_S = 300;\n\n/** Properties allowed on results of callbacks. */\nconst RESULT_PROPERTIES = ['accessToken', 'expiresInSeconds', 'refreshToken'];\n\n/** Error message when the callback result is invalid. */\nconst CALLBACK_RESULT_ERROR =\n  'User provided OIDC callbacks must return a valid object with an accessToken.';\n\n/**\n * OIDC implementation of a callback based workflow.\n * @internal\n */\nexport class CallbackWorkflow implements Workflow {\n  cache: TokenEntryCache;\n  callbackCache: CallbackLockCache;\n\n  /**\n   * Instantiate the workflow\n   */\n  constructor() {\n    this.cache = new TokenEntryCache();\n    this.callbackCache = new CallbackLockCache();\n  }\n\n  /**\n   * Get the document to add for speculative authentication. This also needs\n   * to add a db field from the credentials source.\n   */\n  async speculativeAuth(credentials: MongoCredentials): Promise<Document> {\n    const document = startCommandDocument(credentials);\n    document.db = credentials.source;\n    return { speculativeAuthenticate: document };\n  }\n\n  /**\n   * Execute the OIDC callback workflow.\n   */\n  async execute(\n    connection: Connection,\n    credentials: MongoCredentials,\n    reauthenticating: boolean,\n    response?: Document\n  ): Promise<Document> {\n    // Get the callbacks with locks from the callback lock cache.\n    const { requestCallback, refreshCallback, callbackHash } = this.callbackCache.getCallbacks(\n      connection,\n      credentials\n    );\n    // Look for an existing entry in the cache.\n    const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);\n    let result;\n    if (entry) {\n      // Reauthentication cannot use a token from the cache since the server has\n      // stated it is invalid by the request for reauthentication.\n      if (entry.isValid() && !reauthenticating) {\n        // Presence of a valid cache entry means we can skip to the finishing step.\n        result = await this.finishAuthentication(\n          connection,\n          credentials,\n          entry.tokenResult,\n          response?.speculativeAuthenticate?.conversationId\n        );\n      } else {\n        // Presence of an expired cache entry means we must fetch a new one and\n        // then execute the final step.\n        const tokenResult = await this.fetchAccessToken(\n          connection,\n          credentials,\n          entry.serverInfo,\n          reauthenticating,\n          callbackHash,\n          requestCallback,\n          refreshCallback\n        );\n        try {\n          result = await this.finishAuthentication(\n            connection,\n            credentials,\n            tokenResult,\n            reauthenticating ? undefined : response?.speculativeAuthenticate?.conversationId\n          );\n        } catch (error) {\n          // If we are reauthenticating and this errors with reauthentication\n          // required, we need to do the entire process over again and clear\n          // the cache entry.\n          if (\n            reauthenticating &&\n            error instanceof MongoError &&\n            error.code === MONGODB_ERROR_CODES.Reauthenticate\n          ) {\n            this.cache.deleteEntry(connection.address, credentials.username, callbackHash);\n            result = await this.execute(connection, credentials, reauthenticating);\n          } else {\n            throw error;\n          }\n        }\n      }\n    } else {\n      // No entry in the cache requires us to do all authentication steps\n      // from start to finish, including getting a fresh token for the cache.\n      const startDocument = await this.startAuthentication(\n        connection,\n        credentials,\n        reauthenticating,\n        response\n      );\n      const conversationId = startDocument.conversationId;\n      const serverResult = BSON.deserialize(startDocument.payload.buffer) as IdPServerInfo;\n      const tokenResult = await this.fetchAccessToken(\n        connection,\n        credentials,\n        serverResult,\n        reauthenticating,\n        callbackHash,\n        requestCallback,\n        refreshCallback\n      );\n      result = await this.finishAuthentication(\n        connection,\n        credentials,\n        tokenResult,\n        conversationId\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Starts the callback authentication process. If there is a speculative\n   * authentication document from the initial handshake, then we will use that\n   * value to get the issuer, otherwise we will send the saslStart command.\n   */\n  private async startAuthentication(\n    connection: Connection,\n    credentials: MongoCredentials,\n    reauthenticating: boolean,\n    response?: Document\n  ): Promise<Document> {\n    let result;\n    if (!reauthenticating && response?.speculativeAuthenticate) {\n      result = response.speculativeAuthenticate;\n    } else {\n      result = await connection.commandAsync(\n        ns(credentials.source),\n        startCommandDocument(credentials),\n        undefined\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Finishes the callback authentication process.\n   */\n  private async finishAuthentication(\n    connection: Connection,\n    credentials: MongoCredentials,\n    tokenResult: IdPServerResponse,\n    conversationId?: number\n  ): Promise<Document> {\n    const result = await connection.commandAsync(\n      ns(credentials.source),\n      finishCommandDocument(tokenResult.accessToken, conversationId),\n      undefined\n    );\n    return result;\n  }\n\n  /**\n   * Fetches an access token using either the request or refresh callbacks and\n   * puts it in the cache.\n   */\n  private async fetchAccessToken(\n    connection: Connection,\n    credentials: MongoCredentials,\n    serverInfo: IdPServerInfo,\n    reauthenticating: boolean,\n    callbackHash: string,\n    requestCallback: OIDCRequestFunction,\n    refreshCallback?: OIDCRefreshFunction\n  ): Promise<IdPServerResponse> {\n    // Get the token from the cache.\n    const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);\n    let result;\n    const context: OIDCCallbackContext = { timeoutSeconds: TIMEOUT_S, version: OIDC_VERSION };\n    // Check if there's a token in the cache.\n    if (entry) {\n      // If the cache entry is valid, return the token result.\n      if (entry.isValid() && !reauthenticating) {\n        return entry.tokenResult;\n      }\n      // If the cache entry is not valid, remove it from the cache and first attempt\n      // to use the refresh callback to get a new token. If no refresh callback\n      // exists, then fallback to the request callback.\n      if (refreshCallback) {\n        context.refreshToken = entry.tokenResult.refreshToken;\n        result = await refreshCallback(serverInfo, context);\n      } else {\n        result = await requestCallback(serverInfo, context);\n      }\n    } else {\n      // With no token in the cache we use the request callback.\n      result = await requestCallback(serverInfo, context);\n    }\n    // Validate that the result returned by the callback is acceptable. If it is not\n    // we must clear the token result from the cache.\n    if (isCallbackResultInvalid(result)) {\n      this.cache.deleteEntry(connection.address, credentials.username, callbackHash);\n      throw new MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);\n    }\n    // Cleanup the cache.\n    this.cache.deleteExpiredEntries();\n    // Put the new entry into the cache.\n    this.cache.addEntry(\n      connection.address,\n      credentials.username || '',\n      callbackHash,\n      result,\n      serverInfo\n    );\n    return result;\n  }\n}\n\n/**\n * Generate the finishing command document for authentication. Will be a\n * saslStart or saslContinue depending on the presence of a conversation id.\n */\nfunction finishCommandDocument(token: string, conversationId?: number): Document {\n  if (conversationId != null && typeof conversationId === 'number') {\n    return {\n      saslContinue: 1,\n      conversationId: conversationId,\n      payload: new Binary(BSON.serialize({ jwt: token }))\n    };\n  }\n  // saslContinue requires a conversationId in the command to be valid so in this\n  // case the server allows \"step two\" to actually be a saslStart with the token\n  // as the jwt since the use of the cached value has no correlating conversating\n  // on the particular connection.\n  return {\n    saslStart: 1,\n    mechanism: AuthMechanism.MONGODB_OIDC,\n    payload: new Binary(BSON.serialize({ jwt: token }))\n  };\n}\n\n/**\n * Determines if a result returned from a request or refresh callback\n * function is invalid. This means the result is nullish, doesn't contain\n * the accessToken required field, and does not contain extra fields.\n */\nfunction isCallbackResultInvalid(tokenResult: unknown): boolean {\n  if (tokenResult == null || typeof tokenResult !== 'object') return true;\n  if (!('accessToken' in tokenResult)) return true;\n  return !Object.getOwnPropertyNames(tokenResult).every(prop => RESULT_PROPERTIES.includes(prop));\n}\n\n/**\n * Generate the saslStart command document.\n */\nfunction startCommandDocument(credentials: MongoCredentials): Document {\n  const payload: Document = {};\n  if (credentials.username) {\n    payload.n = credentials.username;\n  }\n  return {\n    saslStart: 1,\n    autoAuthorize: 1,\n    mechanism: AuthMechanism.MONGODB_OIDC,\n    payload: new Binary(BSON.serialize(payload))\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}